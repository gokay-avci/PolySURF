use std::path::{Path, PathBuf};
use std::fs;
use anyhow::{Result, Context, anyhow};

// Expose internal modules
pub mod tools;
pub mod types;

use crate::tools::ExternalTools;
use crate::types::MofArtifacts;

/// The main entry point for library consumers.
/// Runs the full MOFid pipeline on a single CIF and returns the file manifest.
///
/// # Arguments
/// * `cif_path` - Path to the input .cif file.
/// * `output_root` - Directory where intermediate files will be generated.
pub fn analyze_cif(cif_path: &Path, output_root: &Path) -> Result<MofArtifacts> {
    let tools = ExternalTools::new().context("Failed to initialize external MOFid tools")?;
    
    // 1. Prepare Workspace
    let filename_stem = cif_path.file_stem()
        .unwrap_or_default()
        .to_string_lossy();
    
    // Specific folder for this MOF to avoid collisions
    let specific_out = output_root.join(filename_stem.as_ref());
    
    if specific_out.exists() {
        // Clean previous run artifacts
        fs::remove_dir_all(&specific_out).ok();
    }
    fs::create_dir_all(&specific_out).context("Failed to create output directory")?;

    // Canonicalize paths to ensure external binaries don't get confused
    let abs_cif = fs::canonicalize(cif_path).unwrap_or(cif_path.to_path_buf());
    let abs_out = fs::canonicalize(&specific_out).unwrap_or(specific_out.clone());

    // 2. Run the SBU Extraction (Decomposition)
    // This calls the 'sbu' binary which splits the CIF into Nodes/*.xyz and Linkers/*.xyz
    tools.run_cmd(
        &tools.sbu_bin, 
        &[abs_cif.as_os_str(), abs_out.as_os_str()], 
        None, 
        None
    ).context("Failed to run SBU decomposition binary")?;

    // 3. Determine output pattern.
    //
    // The legacy SBU tool produces `Nodes` and `Linkers` directories containing XYZ files.
    // The newer pipeline (AllNode mode) produces a single `AllNode` directory containing
    // `nodes.cif` and `linkers.cif`. We detect which pattern is present and return the
    // appropriate directories. If neither exists, we bail out.
    let default_nodes_dir = abs_out.join("Nodes");
    let default_linkers_dir = abs_out.join("Linkers");
    let (nodes_dir, linkers_dir) = if default_nodes_dir.exists() {
        (default_nodes_dir, default_linkers_dir)
    } else {
        let all_node_dir = abs_out.join("AllNode");
        if all_node_dir.exists() {
            // Both nodes and linkers live in this directory
            (all_node_dir.clone(), all_node_dir)
        } else {
            return Err(anyhow!("MOFid decomposition failed: neither 'Nodes' nor 'AllNode' directories were generated at {:?}", abs_out));
        }
    };

    // 4. Check for Topology Abstractions (Optional)
    // MOFid usually creates `SingleNode/underlying_net.cif`
    let underlying_cif_path = abs_out.join("SingleNode").join("underlying_net.cif");
    let underlying_net_cif = if underlying_cif_path.exists() {
        Some(underlying_cif_path)
    } else {
        None
    };

    // 5. Run Systre for Topology Identification (Optional but useful)
    // We try to determine the topology name (e.g., "pcu", "fcu")
    // This requires the .cgd file usually generated by the SBU tool.
    let cgd_path = abs_out.join("SingleNode").join("topology.cgd");
    let topology = if cgd_path.exists() {
        // Run Systre wrapper
        // Note: We use a short timeout because Systre can hang on complex nets
        match tools.run_cmd(
            &tools.java_bin,
            &["-jar", tools.systre_jar.to_str().unwrap(), cgd_path.to_str().unwrap()],
            None,
            Some(std::time::Duration::from_secs(30))
        ) {
            Ok(output) => {
                // Parse the first "Name: xyz" line
                output.lines()
                    .find(|line| line.trim().starts_with("Name:"))
                    .map(|line| line.split_whitespace().nth(1).unwrap_or("unknown").to_string())
            },
            Err(_) => Some("timeout".to_string())
        }
    } else {
        None
    };

    Ok(MofArtifacts {
        name: filename_stem.to_string(),
        output_root: abs_out,
        nodes_dir,
        linkers_dir,
        underlying_net_cif,
        mofid: format!("Generated-{}", filename_stem), // Placeholder for full ID logic
        topology,
    })
}